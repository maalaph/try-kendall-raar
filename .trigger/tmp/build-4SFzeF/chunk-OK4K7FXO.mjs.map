{
  "version": 3,
  "sources": ["../../../trigger/learning-loops.ts", "../../../lib/patternExtractor.ts", "../../../lib/userPatterns.ts"],
  "sourcesContent": ["/**\n * Trigger.dev Learning Loop Tasks\n * Async tasks for pattern extraction, memory consolidation, and learning\n */\n\nimport { task } from \"@trigger.dev/sdk/v3\";\nimport { extractPatternsFromMessage } from \"@/lib/patternExtractor\";\nimport { getUserPatterns, getUserMemories, upsertUserMemory, UserPattern, UserMemory } from \"@/lib/database\";\nimport { getChatMessages } from \"@/lib/database\";\nimport { batchIndexMessages, indexMemory } from \"@/lib/semanticMemory\";\n\n/**\n * Extract patterns from a user message asynchronously\n */\nexport const extractPatternsTask = task({\n  id: \"extract-patterns\",\n  run: async (payload: {\n    recordId: string;\n    message: string;\n    role: 'user' | 'assistant';\n    timestamp: string;\n    previousMessages?: Array<{\n      message: string;\n      role: 'user' | 'assistant';\n      timestamp: string;\n    }>;\n  }) => {\n    try {\n      console.log('[TRIGGER] Starting pattern extraction task:', {\n        recordId: payload.recordId,\n        messageLength: payload.message.length,\n      });\n\n      await extractPatternsFromMessage(\n        payload.recordId,\n        payload.message,\n        payload.role,\n        payload.timestamp,\n        payload.previousMessages || []\n      );\n\n      console.log('[TRIGGER] Pattern extraction completed successfully');\n      return { success: true };\n    } catch (error) {\n      console.error('[TRIGGER] Pattern extraction failed:', error);\n      throw error;\n    }\n  },\n});\n\n/**\n * Batch extract patterns from multiple messages\n */\nexport const batchExtractPatternsTask = task({\n  id: \"batch-extract-patterns\",\n  run: async (payload: {\n    recordId: string;\n    messages: Array<{\n      message: string;\n      role: 'user' | 'assistant';\n      timestamp: string;\n    }>;\n  }) => {\n    try {\n      console.log('[TRIGGER] Starting batch pattern extraction:', {\n        recordId: payload.recordId,\n        messageCount: payload.messages.length,\n      });\n\n      const results = [];\n      for (const msg of payload.messages) {\n        try {\n          await extractPatternsFromMessage(\n            payload.recordId,\n            msg.message,\n            msg.role,\n            msg.timestamp,\n            payload.messages.filter(m => m.timestamp < msg.timestamp)\n          );\n          results.push({ success: true, message: msg.message.substring(0, 50) });\n        } catch (error) {\n          console.error('[TRIGGER] Failed to extract patterns for message:', error);\n          results.push({ success: false, error: error instanceof Error ? error.message : String(error) });\n        }\n      }\n\n      return { results, total: payload.messages.length, successful: results.filter(r => r.success).length };\n    } catch (error) {\n      console.error('[TRIGGER] Batch pattern extraction failed:', error);\n      throw error;\n    }\n  },\n});\n\n/**\n * Consolidate and update user memories\n */\nexport const consolidateMemoriesTask = task({\n  id: \"consolidate-memories\",\n  run: async (payload: {\n    recordId: string;\n  }) => {\n    try {\n      console.log('[TRIGGER] Starting memory consolidation:', {\n        recordId: payload.recordId,\n      });\n\n      const memories = await getUserMemories(payload.recordId);\n      \n      // Group similar memories by key prefix\n      const memoryGroups = new Map<string, UserMemory[]>();\n      \n      for (const memory of memories) {\n        // Extract base key (before any suffix)\n        const baseKey = memory.key.split('_')[0] || memory.key;\n        \n        if (!memoryGroups.has(baseKey)) {\n          memoryGroups.set(baseKey, []);\n        }\n        memoryGroups.get(baseKey)!.push(memory);\n      }\n\n      // Consolidate similar memories\n      let consolidated = 0;\n      for (const [baseKey, group] of memoryGroups.entries()) {\n        if (group.length > 1) {\n          // Find the most important/recent memory\n          const primary = group.sort((a, b) => {\n            const importanceOrder = { high: 3, medium: 2, low: 1 };\n            const aImp = importanceOrder[a.importance || 'medium'];\n            const bImp = importanceOrder[b.importance || 'medium'];\n            if (aImp !== bImp) return bImp - aImp;\n            \n            const aTime = a.createdAt ? new Date(a.createdAt).getTime() : 0;\n            const bTime = b.createdAt ? new Date(b.createdAt).getTime() : 0;\n            return bTime - aTime;\n          })[0];\n\n          // Merge context from other memories\n          const contexts = group\n            .filter(m => m.id !== primary.id && m.context)\n            .map(m => m.context)\n            .filter(Boolean);\n          \n          if (contexts.length > 0) {\n            primary.context = [primary.context, ...contexts].filter(Boolean).join('; ');\n          }\n\n          // Update primary memory\n          await upsertUserMemory(primary);\n\n          // Mark others for deletion (or update to point to primary)\n          consolidated += group.length - 1;\n        }\n      }\n\n      // Clean up expired memories\n      const now = new Date();\n      const expired = memories.filter(m => m.expiresAt && new Date(m.expiresAt) < now);\n      \n      // Note: We don't have a delete function in database.ts yet, so we'll just log\n      console.log(`[TRIGGER] Found ${expired.length} expired memories (cleanup not implemented yet)`);\n\n      console.log('[TRIGGER] Memory consolidation completed:', {\n        totalMemories: memories.length,\n        consolidated,\n        expired: expired.length,\n      });\n\n      return {\n        success: true,\n        totalMemories: memories.length,\n        consolidated,\n        expired: expired.length,\n      };\n    } catch (error) {\n      console.error('[TRIGGER] Memory consolidation failed:', error);\n      throw error;\n    }\n  },\n});\n\n/**\n * Update pattern confidence scores based on recent observations\n */\nexport const updatePatternConfidenceTask = task({\n  id: \"update-pattern-confidence\",\n  run: async (payload: {\n    recordId: string;\n  }) => {\n    try {\n      console.log('[TRIGGER] Starting pattern confidence update:', {\n        recordId: payload.recordId,\n      });\n\n      const patterns = await getUserPatterns(payload.recordId);\n      \n      // Get recent messages to check pattern matches\n      const threadId = await require('@/lib/database').getOrCreateThreadId(payload.recordId);\n      const recentMessages = await getChatMessages({\n        threadId,\n        limit: 100,\n      });\n\n      let updated = 0;\n      for (const pattern of patterns) {\n        let matches = 0;\n        \n        // Check if pattern matches recent messages\n        for (const msg of recentMessages.messages) {\n          const msgLower = msg.message.toLowerCase();\n          const patternDesc = pattern.patternData.description?.toLowerCase() || '';\n          \n          // Simple matching logic (can be enhanced)\n          if (patternDesc && msgLower.includes(patternDesc.split(' ')[0])) {\n            matches++;\n          }\n        }\n\n        // Update confidence based on matches\n        if (matches > 0) {\n          const newConfidence = Math.min(1, (pattern.confidence || 0.5) + (matches * 0.1));\n          if (newConfidence !== pattern.confidence) {\n            await require('@/lib/database').upsertUserPattern({\n              ...pattern,\n              confidence: newConfidence,\n              lastObserved: new Date().toISOString(),\n            });\n            updated++;\n          }\n        } else {\n          // Decrease confidence if no recent matches\n          const newConfidence = Math.max(0.1, (pattern.confidence || 0.5) - 0.05);\n          if (newConfidence !== pattern.confidence) {\n            await require('@/lib/database').upsertUserPattern({\n              ...pattern,\n              confidence: newConfidence,\n            });\n            updated++;\n          }\n        }\n      }\n\n      console.log('[TRIGGER] Pattern confidence update completed:', {\n        totalPatterns: patterns.length,\n        updated,\n      });\n\n      return {\n        success: true,\n        totalPatterns: patterns.length,\n        updated,\n      };\n    } catch (error) {\n      console.error('[TRIGGER] Pattern confidence update failed:', error);\n      throw error;\n    }\n  },\n});\n\n", "/**\n * Pattern Extraction from Conversations\n * Automatically extracts user patterns from chat history for learning system\n */\n\nimport { upsertUserPattern, getUserPatterns, UserPattern } from './userPatterns';\n\nexport interface PatternExtraction {\n  patternType: UserPattern['patternType'];\n  patternData: UserPattern['patternData'];\n  confidence: number;\n}\n\n/**\n * Extract patterns from a conversation message\n */\nexport async function extractPatternsFromMessage(\n  recordId: string,\n  message: string,\n  role: 'user' | 'assistant',\n  timestamp: string,\n  previousMessages?: Array<{ message: string; role: 'user' | 'assistant'; timestamp: string }>\n): Promise<void> {\n  if (role !== 'user') return; // Only analyze user messages\n\n  const patterns: PatternExtraction[] = [];\n\n  // Extract recurring call patterns\n  const callPattern = extractRecurringCallPattern(message, previousMessages || []);\n  if (callPattern) {\n    patterns.push(callPattern);\n  }\n\n  // Extract time-based preferences\n  const timePattern = extractTimeBasedPattern(message);\n  if (timePattern) {\n    patterns.push(timePattern);\n  }\n\n  // Extract contact preferences\n  const contactPattern = extractContactPattern(message, previousMessages || []);\n  if (contactPattern) {\n    patterns.push(contactPattern);\n  }\n\n  // Extract preferences\n  const preferencePattern = extractPreferencePattern(message);\n  if (preferencePattern) {\n    patterns.push(preferencePattern);\n  }\n\n  // Save patterns (gracefully handle missing tables)\n  console.log('[PATTERN EXTRACTION] Extracted', patterns.length, 'pattern(s) from message');\n  \n  for (const pattern of patterns) {\n    try {\n      console.log('[PATTERN EXTRACTION] Processing pattern:', {\n        type: pattern.patternType,\n        confidence: pattern.confidence,\n        description: pattern.patternData.description,\n      });\n      \n      // Check if similar pattern exists\n      const existingPatterns = await getUserPatterns(recordId, pattern.patternType);\n      const similarPattern = existingPatterns.find(\n        (p) => JSON.stringify(p.patternData) === JSON.stringify(pattern.patternData)\n      );\n\n      if (similarPattern) {\n        // Update existing pattern confidence\n        console.log('[PATTERN EXTRACTION] Updating existing pattern, increasing confidence from', similarPattern.confidence);\n        await upsertUserPattern({\n          ...similarPattern,\n          confidence: Math.min(1, similarPattern.confidence + 0.1), // Increase confidence\n          lastObserved: timestamp,\n        });\n        console.log('[PATTERN EXTRACTION] Successfully updated pattern');\n      } else {\n        // Create new pattern\n        console.log('[PATTERN EXTRACTION] Creating new pattern');\n        await upsertUserPattern({\n          recordId,\n          patternType: pattern.patternType,\n          patternData: pattern.patternData,\n          confidence: pattern.confidence,\n          lastObserved: timestamp,\n        });\n        console.log('[PATTERN EXTRACTION] Successfully created new pattern');\n      }\n    } catch (error) {\n      // Gracefully handle missing tables - don't break the flow\n      console.error('[PATTERN EXTRACTION] Could not save pattern:', error);\n      console.error('[PATTERN EXTRACTION] Error details:', {\n        patternType: pattern.patternType,\n        recordId,\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n      // Continue processing - pattern extraction doesn't break if storage fails\n    }\n  }\n  \n  if (patterns.length === 0) {\n    console.log('[PATTERN EXTRACTION] No patterns detected in message');\n  }\n}\n\n/**\n * Extract recurring call pattern\n */\nfunction extractRecurringCallPattern(\n  message: string,\n  previousMessages: Array<{ message: string; role: string; timestamp: string }>\n): PatternExtraction | null {\n  const lowerMessage = message.toLowerCase();\n\n  // Look for calls to specific contacts\n  const callMatches = lowerMessage.match(/(?:call|phone|dial|contact)\\s+([a-z]+(?:\\s+[a-z]+)?)/i);\n  if (!callMatches) return null;\n\n  const contactName = callMatches[1].trim();\n  \n  // Look for day/time mentions\n  const dayMatch = lowerMessage.match(/(monday|tuesday|wednesday|thursday|friday|saturday|sunday|weekday|weekend)/i);\n  const timeMatch = lowerMessage.match(/(\\d{1,2}):(\\d{2})\\s*(am|pm)?/i) || \n                    lowerMessage.match(/(\\d{1,2})\\s*(am|pm)/i);\n\n  // Check if this is mentioned multiple times in recent messages\n  const recentCallCount = previousMessages.filter(\n    (m) => m.role === 'user' && m.message.toLowerCase().includes(contactName.toLowerCase())\n  ).length;\n\n  if (recentCallCount >= 2) {\n    const dayOfWeek = dayMatch ? getDayOfWeek(dayMatch[1]) : undefined;\n    const timeOfDay = timeMatch ? extractTime(timeMatch) : undefined;\n\n    return {\n      patternType: 'recurring_call',\n      patternData: {\n        description: `Calls ${contactName}${dayOfWeek !== undefined ? ` on ${getDayName(dayOfWeek)}` : ''}${timeOfDay ? ` at ${timeOfDay}` : ''}`,\n        frequency: dayOfWeek !== undefined ? 'weekly' : undefined,\n        dayOfWeek,\n        timeOfDay,\n        contactName,\n        metadata: { observedCount: recentCallCount },\n      },\n      confidence: Math.min(0.8, 0.3 + recentCallCount * 0.1),\n    };\n  }\n\n  return null;\n}\n\n/**\n * Extract time-based pattern\n */\nfunction extractTimeBasedPattern(message: string): PatternExtraction | null {\n  const lowerMessage = message.toLowerCase();\n\n  // Look for preferences about time\n  const morningPref = /(morning|before noon|early|9am|10am|11am)/i.test(lowerMessage);\n  const afternoonPref = /(afternoon|after noon|2pm|3pm|4pm)/i.test(lowerMessage);\n  const eveningPref = /(evening|night|after 5|after 6)/i.test(lowerMessage);\n\n  if (morningPref || afternoonPref || eveningPref) {\n    return {\n      patternType: 'time_based_action',\n      patternData: {\n        description: `Prefers ${morningPref ? 'morning' : afternoonPref ? 'afternoon' : 'evening'} activities`,\n        timeOfDay: morningPref ? '09:00' : afternoonPref ? '14:00' : '18:00',\n      },\n      confidence: 0.6,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Extract contact pattern\n */\nfunction extractContactPattern(\n  message: string,\n  previousMessages: Array<{ message: string; role: string; timestamp: string }>\n): PatternExtraction | null {\n  const lowerMessage = message.toLowerCase();\n\n  // Look for contact mentions with context\n  const contactMatches = lowerMessage.match(/(?:call|message|contact|reach out to|talk to)\\s+([a-z]+(?:\\s+[a-z]+)?)/i);\n  if (!contactMatches) return null;\n\n  const contactName = contactMatches[1].trim();\n  \n  // Check frequency\n  const mentionCount = previousMessages.filter(\n    (m) => m.message.toLowerCase().includes(contactName.toLowerCase())\n  ).length;\n\n  if (mentionCount >= 3) {\n    return {\n      patternType: 'preferred_contact',\n      patternData: {\n        description: `Frequently contacts ${contactName}`,\n        contactName,\n        metadata: { mentionCount },\n      },\n      confidence: Math.min(0.9, 0.5 + mentionCount * 0.1),\n    };\n  }\n\n  return null;\n}\n\n/**\n * Extract preference pattern\n */\nfunction extractPreferencePattern(message: string): PatternExtraction | null {\n  const lowerMessage = message.toLowerCase();\n\n  // Look for preference statements\n  const preferencePatterns = [\n    /(?:i|i'd|i would|i prefer|i like).*?(always|never|prefer|like|don't like)/i,\n    /(?:remember|note|important).*?(always|never|prefer)/i,\n  ];\n\n  for (const pattern of preferencePatterns) {\n    if (pattern.test(lowerMessage)) {\n      return {\n        patternType: 'preference',\n        patternData: {\n          description: message.substring(0, 100), // First 100 chars\n          metadata: { extracted: true },\n        },\n        confidence: 0.7,\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Helper: Get day of week number\n */\nfunction getDayOfWeek(dayName: string): number {\n  const days: Record<string, number> = {\n    sunday: 0,\n    monday: 1,\n    tuesday: 2,\n    wednesday: 3,\n    thursday: 4,\n    friday: 5,\n    saturday: 6,\n  };\n  return days[dayName.toLowerCase()] ?? -1;\n}\n\n/**\n * Helper: Get day name from number\n */\nfunction getDayName(day: number): string {\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  return days[day] || '';\n}\n\n/**\n * Helper: Extract time from match\n */\nfunction extractTime(match: RegExpMatchArray): string {\n  if (match[3]) {\n    // Has AM/PM\n    let hour = parseInt(match[1]);\n    const minute = match[2] ? parseInt(match[2]) : 0;\n    const ampm = match[3]?.toLowerCase() || match[2]?.toLowerCase();\n    \n    if (ampm === 'pm' && hour !== 12) hour += 12;\n    if (ampm === 'am' && hour === 12) hour = 0;\n    \n    return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n  } else {\n    // 24-hour format\n    const hour = parseInt(match[1]);\n    const minute = match[2] ? parseInt(match[2]) : 0;\n    return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n  }\n}\n\n", "/**\n * User Patterns and Memory Management\n * Stores and retrieves user behavior patterns, preferences, and long-term memory\n */\n\nconst AIRTABLE_BASE_ID = process.env.AIRTABLE_BASE_ID;\nconst USER_PATTERNS_TABLE_ID = process.env.AIRTABLE_USER_PATTERNS_TABLE_ID;\nconst USER_MEMORY_TABLE_ID = process.env.AIRTABLE_USER_MEMORY_TABLE_ID;\n\nconst USER_PATTERNS_API_URL = AIRTABLE_BASE_ID && USER_PATTERNS_TABLE_ID\n  ? `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${USER_PATTERNS_TABLE_ID}`\n  : '';\n\nconst USER_MEMORY_API_URL = AIRTABLE_BASE_ID && USER_MEMORY_TABLE_ID\n  ? `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${USER_MEMORY_TABLE_ID}`\n  : '';\n\nconst getHeaders = () => ({\n  'Authorization': `Bearer ${process.env.AIRTABLE_API_KEY}`,\n  'Content-Type': 'application/json',\n});\n\n/**\n * User Pattern Types\n */\nexport interface UserPattern {\n  id?: string;\n  recordId: string; // Link to main user record\n  patternType: 'recurring_call' | 'time_based_action' | 'preferred_contact' | 'behavior' | 'preference';\n  patternData: {\n    description: string;\n    frequency?: 'daily' | 'weekly' | 'monthly' | 'custom';\n    dayOfWeek?: number; // 0-6 (Sunday-Saturday)\n    timeOfDay?: string; // HH:MM format\n    contactName?: string;\n    contactPhone?: string;\n    metadata?: Record<string, any>;\n  };\n  confidence?: number; // 0-1, how confident we are in this pattern\n  lastObserved?: string; // ISO timestamp\n  createdAt?: string;\n  updatedAt?: string;\n}\n\n/**\n * User Memory Types\n */\nexport interface UserMemory {\n  id?: string;\n  recordId: string; // Link to main user record\n  memoryType: 'fact' | 'preference' | 'relationship' | 'reminder' | 'important_date' | 'instruction';\n  key: string; // Unique key for this memory\n  value: string; // The actual memory content\n  context?: string; // Additional context about this memory\n  importance?: 'low' | 'medium' | 'high';\n  expiresAt?: string; // ISO timestamp - when this memory expires (optional)\n  createdAt?: string;\n  updatedAt?: string;\n}\n\n/**\n * Create or update a user pattern\n */\nexport async function upsertUserPattern(pattern: UserPattern): Promise<UserPattern> {\n  try {\n    if (!USER_PATTERNS_API_URL) {\n      console.warn('[USER PATTERNS] USER_PATTERNS_TABLE_ID not configured. Pattern will not be saved.');\n      return pattern;\n    }\n\n    const fields: Record<string, any> = {\n      recordId: [pattern.recordId], // Linked record\n      patternType: pattern.patternType,\n      patternData: JSON.stringify(pattern.patternData),\n      confidence: pattern.confidence || 0.5,\n      lastObserved: pattern.lastObserved || new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n\n    if (pattern.createdAt) {\n      fields.createdAt = pattern.createdAt;\n    } else {\n      fields.createdAt = new Date().toISOString();\n    }\n\n    // Try to find existing pattern first\n    if (pattern.id) {\n      // Update existing\n      const url = `${USER_PATTERNS_API_URL}/${pattern.id}`;\n      const response = await fetch(url, {\n        method: 'PATCH',\n        headers: getHeaders(),\n        body: JSON.stringify({ fields }),\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        return parsePatternFromRecord(result);\n      }\n    }\n\n    // Create new\n    const response = await fetch(USER_PATTERNS_API_URL, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({ fields }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      const errorMessage = errorData.error?.message || `Failed to create pattern: ${response.status}`;\n      console.error('[USER PATTERNS] Failed to create pattern:', {\n        status: response.status,\n        statusText: response.statusText,\n        errorData,\n        patternType: pattern.patternType,\n        recordId: pattern.recordId,\n        hasTableId: !!USER_PATTERNS_TABLE_ID,\n        tableId: USER_PATTERNS_TABLE_ID,\n      });\n      throw new Error(errorMessage);\n    }\n\n    const result = await response.json();\n    console.log('[USER PATTERNS] Successfully saved pattern:', {\n      patternType: pattern.patternType,\n      recordId: pattern.recordId,\n      patternId: result.id,\n      confidence: pattern.confidence,\n    });\n    return parsePatternFromRecord(result);\n  } catch (error) {\n    console.error('[USER PATTERNS] Failed to upsert pattern:', error);\n    console.error('[USER PATTERNS] Error details:', {\n      patternType: pattern.patternType,\n      recordId: pattern.recordId,\n      hasTableId: !!USER_PATTERNS_TABLE_ID,\n      error: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n    throw error;\n  }\n}\n\n/**\n * Get user patterns for a specific user\n */\nexport async function getUserPatterns(recordId: string, patternType?: UserPattern['patternType']): Promise<UserPattern[]> {\n  try {\n    if (!USER_PATTERNS_API_URL) {\n      return [];\n    }\n\n    let filterFormula = `{recordId} = \"${recordId}\"`;\n    if (patternType) {\n      filterFormula += ` AND {patternType} = \"${patternType}\"`;\n    }\n\n    const url = `${USER_PATTERNS_API_URL}?filterByFormula=${encodeURIComponent(filterFormula)}&sort[0][field]=lastObserved&sort[0][direction]=desc`;\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: getHeaders(),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      console.error('[USER PATTERNS] Failed to get patterns:', errorData);\n      return [];\n    }\n\n    const result = await response.json();\n    return (result.records || []).map(parsePatternFromRecord);\n  } catch (error) {\n    console.error('[USER PATTERNS] Failed to get patterns:', error);\n    return [];\n  }\n}\n\n/**\n * Create or update a user memory\n */\nexport async function upsertUserMemory(memory: UserMemory): Promise<UserMemory> {\n  try {\n    if (!USER_MEMORY_API_URL) {\n      console.warn('[USER MEMORY] USER_MEMORY_TABLE_ID not configured. Memory will not be saved.');\n      return memory;\n    }\n\n    // Check if memory with this key already exists\n    const existing = await getUserMemoryByKey(memory.recordId, memory.key);\n    \n    const fields: Record<string, any> = {\n      recordId: [memory.recordId], // Linked record\n      memoryType: memory.memoryType,\n      key: memory.key,\n      value: memory.value,\n      importance: memory.importance || 'medium',\n      updatedAt: new Date().toISOString(),\n    };\n\n    if (memory.context) {\n      fields.context = memory.context;\n    }\n\n    if (memory.expiresAt) {\n      fields.expiresAt = memory.expiresAt;\n    }\n\n    if (existing) {\n      // Update existing\n      const url = `${USER_MEMORY_API_URL}/${existing.id}`;\n      const response = await fetch(url, {\n        method: 'PATCH',\n        headers: getHeaders(),\n        body: JSON.stringify({ fields }),\n      });\n\n      if (response.ok) {\n        const result = await response.json();\n        return parseMemoryFromRecord(result);\n      }\n    } else {\n      // Create new\n      fields.createdAt = new Date().toISOString();\n      \n      const response = await fetch(USER_MEMORY_API_URL, {\n        method: 'POST',\n        headers: getHeaders(),\n        body: JSON.stringify({ fields }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error?.message || `Failed to create memory: ${response.status}`);\n      }\n\n      const result = await response.json();\n      return parseMemoryFromRecord(result);\n    }\n\n    return memory;\n  } catch (error) {\n    console.error('[USER MEMORY] Failed to upsert memory:', error);\n    throw error;\n  }\n}\n\n/**\n * Get user memory by key\n */\nexport async function getUserMemoryByKey(recordId: string, key: string): Promise<UserMemory | null> {\n  try {\n    if (!USER_MEMORY_API_URL) {\n      return null;\n    }\n\n    const filterFormula = `{recordId} = \"${recordId}\" AND {key} = \"${key}\"`;\n    const url = `${USER_MEMORY_API_URL}?filterByFormula=${encodeURIComponent(filterFormula)}`;\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: getHeaders(),\n    });\n\n    if (!response.ok) {\n      return null;\n    }\n\n    const result = await response.json();\n    const records = result.records || [];\n    \n    if (records.length > 0) {\n      return parseMemoryFromRecord(records[0]);\n    }\n\n    return null;\n  } catch (error) {\n    console.error('[USER MEMORY] Failed to get memory by key:', error);\n    return null;\n  }\n}\n\n/**\n * Get all user memories\n */\nexport async function getUserMemories(\n  recordId: string,\n  memoryType?: UserMemory['memoryType'],\n  importance?: UserMemory['importance']\n): Promise<UserMemory[]> {\n  try {\n    if (!USER_MEMORY_API_URL) {\n      return [];\n    }\n\n    let filterFormula = `{recordId} = \"${recordId}\"`;\n    \n    if (memoryType) {\n      filterFormula += ` AND {memoryType} = \"${memoryType}\"`;\n    }\n    \n    if (importance) {\n      filterFormula += ` AND {importance} = \"${importance}\"`;\n    }\n\n    // Filter out expired memories\n    const now = new Date().toISOString();\n    filterFormula += ` OR ISBLANK({expiresAt}) OR {expiresAt} > \"${now}\"`;\n\n    const url = `${USER_MEMORY_API_URL}?filterByFormula=${encodeURIComponent(filterFormula)}&sort[0][field]=importance&sort[0][direction]=desc&sort[1][field]=createdAt&sort[1][direction]=desc`;\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: getHeaders(),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      console.error('[USER MEMORY] Failed to get memories:', errorData);\n      return [];\n    }\n\n    const result = await response.json();\n    const memories = (result.records || []).map(parseMemoryFromRecord);\n    \n    // Filter out expired memories client-side as well\n    return memories.filter(m => {\n      if (!m.expiresAt) return true;\n      return new Date(m.expiresAt) > new Date();\n    });\n  } catch (error) {\n    console.error('[USER MEMORY] Failed to get memories:', error);\n    return [];\n  }\n}\n\n/**\n * Delete a user memory\n */\nexport async function deleteUserMemory(memoryId: string): Promise<void> {\n  try {\n    if (!USER_MEMORY_API_URL) {\n      return;\n    }\n\n    const url = `${USER_MEMORY_API_URL}/${memoryId}`;\n    const response = await fetch(url, {\n      method: 'DELETE',\n      headers: getHeaders(),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new Error(errorData.error?.message || `Failed to delete memory: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('[USER MEMORY] Failed to delete memory:', error);\n    throw error;\n  }\n}\n\n/**\n * Helper: Parse pattern from Airtable record\n */\nfunction parsePatternFromRecord(record: any): UserPattern {\n  return {\n    id: record.id,\n    recordId: Array.isArray(record.fields?.recordId) \n      ? record.fields.recordId[0] \n      : record.fields?.recordId || '',\n    patternType: record.fields?.patternType || 'behavior',\n    patternData: typeof record.fields?.patternData === 'string'\n      ? JSON.parse(record.fields.patternData)\n      : record.fields?.patternData || {},\n    confidence: record.fields?.confidence || 0.5,\n    lastObserved: record.fields?.lastObserved || record.fields?.createdAt,\n    createdAt: record.fields?.createdAt,\n    updatedAt: record.fields?.updatedAt,\n  };\n}\n\n/**\n * Helper: Parse memory from Airtable record\n */\nfunction parseMemoryFromRecord(record: any): UserMemory {\n  return {\n    id: record.id,\n    recordId: Array.isArray(record.fields?.recordId)\n      ? record.fields.recordId[0]\n      : record.fields?.recordId || '',\n    memoryType: record.fields?.memoryType || 'fact',\n    key: record.fields?.key || '',\n    value: record.fields?.value || '',\n    context: record.fields?.context,\n    importance: record.fields?.importance || 'medium',\n    expiresAt: record.fields?.expiresAt,\n    createdAt: record.fields?.createdAt,\n    updatedAt: record.fields?.updatedAt,\n  };\n}\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;;;ACAA;;;ACAA;AAKA,IAAM,mBAAmB,QAAQ,IAAI;AACrC,IAAM,yBAAyB,QAAQ,IAAI;AAC3C,IAAM,uBAAuB,QAAQ,IAAI;AAEzC,IAAM,wBAAwB,oBAAoB,yBAC9C,+BAA+B,gBAAgB,IAAI,sBAAsB,KACzE;AAEJ,IAAM,sBAAsB,oBAAoB,uBAC5C,+BAA+B,gBAAgB,IAAI,oBAAoB,KACvE;AAEJ,IAAM,aAAa,8BAAO;AAAA,EACxB,iBAAiB,UAAU,QAAQ,IAAI,gBAAgB;AAAA,EACvD,gBAAgB;AAClB,IAHmB;AA8CnB,eAAsB,kBAAkB,SAA4C;AAClF,MAAI;AACF,QAAI,CAAC,uBAAuB;AAC1B,cAAQ,KAAK,mFAAmF;AAChG,aAAO;AAAA,IACT;AAEA,UAAM,SAA8B;AAAA,MAClC,UAAU,CAAC,QAAQ,QAAQ;AAAA;AAAA,MAC3B,aAAa,QAAQ;AAAA,MACrB,aAAa,KAAK,UAAU,QAAQ,WAAW;AAAA,MAC/C,YAAY,QAAQ,cAAc;AAAA,MAClC,cAAc,QAAQ,iBAAgB,oBAAI,KAAK,GAAE,YAAY;AAAA,MAC7D,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,QAAI,QAAQ,WAAW;AACrB,aAAO,YAAY,QAAQ;AAAA,IAC7B,OAAO;AACL,aAAO,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,IAC5C;AAGA,QAAI,QAAQ,IAAI;AAEd,YAAM,MAAM,GAAG,qBAAqB,IAAI,QAAQ,EAAE;AAClD,YAAMA,YAAW,MAAM,MAAM,KAAK;AAAA,QAChC,QAAQ;AAAA,QACR,SAAS,WAAW;AAAA,QACpB,MAAM,KAAK,UAAU,EAAE,OAAO,CAAC;AAAA,MACjC,CAAC;AAED,UAAIA,UAAS,IAAI;AACf,cAAMC,UAAS,MAAMD,UAAS,KAAK;AACnC,eAAO,uBAAuBC,OAAM;AAAA,MACtC;AAAA,IACF;AAGA,UAAM,WAAW,MAAM,MAAM,uBAAuB;AAAA,MAClD,QAAQ;AAAA,MACR,SAAS,WAAW;AAAA,MACpB,MAAM,KAAK,UAAU,EAAE,OAAO,CAAC;AAAA,IACjC,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,OAAO,CAAC,EAAE;AACxD,YAAM,eAAe,UAAU,OAAO,WAAW,6BAA6B,SAAS,MAAM;AAC7F,cAAQ,MAAM,6CAA6C;AAAA,QACzD,QAAQ,SAAS;AAAA,QACjB,YAAY,SAAS;AAAA,QACrB;AAAA,QACA,aAAa,QAAQ;AAAA,QACrB,UAAU,QAAQ;AAAA,QAClB,YAAY,CAAC,CAAC;AAAA,QACd,SAAS;AAAA,MACX,CAAC;AACD,YAAM,IAAI,MAAM,YAAY;AAAA,IAC9B;AAEA,UAAM,SAAS,MAAM,SAAS,KAAK;AACnC,YAAQ,IAAI,+CAA+C;AAAA,MACzD,aAAa,QAAQ;AAAA,MACrB,UAAU,QAAQ;AAAA,MAClB,WAAW,OAAO;AAAA,MAClB,YAAY,QAAQ;AAAA,IACtB,CAAC;AACD,WAAO,uBAAuB,MAAM;AAAA,EACtC,SAAS,OAAO;AACd,YAAQ,MAAM,6CAA6C,KAAK;AAChE,YAAQ,MAAM,kCAAkC;AAAA,MAC9C,aAAa,QAAQ;AAAA,MACrB,UAAU,QAAQ;AAAA,MAClB,YAAY,CAAC,CAAC;AAAA,MACd,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC5D,OAAO,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,IAChD,CAAC;AACD,UAAM;AAAA,EACR;AACF;AA/EsB;AAoFtB,eAAsBC,iBAAgB,UAAkB,aAAkE;AACxH,MAAI;AACF,QAAI,CAAC,uBAAuB;AAC1B,aAAO,CAAC;AAAA,IACV;AAEA,QAAI,gBAAgB,iBAAiB,QAAQ;AAC7C,QAAI,aAAa;AACf,uBAAiB,yBAAyB,WAAW;AAAA,IACvD;AAEA,UAAM,MAAM,GAAG,qBAAqB,oBAAoB,mBAAmB,aAAa,CAAC;AAEzF,UAAM,WAAW,MAAM,MAAM,KAAK;AAAA,MAChC,QAAQ;AAAA,MACR,SAAS,WAAW;AAAA,IACtB,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,OAAO,CAAC,EAAE;AACxD,cAAQ,MAAM,2CAA2C,SAAS;AAClE,aAAO,CAAC;AAAA,IACV;AAEA,UAAM,SAAS,MAAM,SAAS,KAAK;AACnC,YAAQ,OAAO,WAAW,CAAC,GAAG,IAAI,sBAAsB;AAAA,EAC1D,SAAS,OAAO;AACd,YAAQ,MAAM,2CAA2C,KAAK;AAC9D,WAAO,CAAC;AAAA,EACV;AACF;AA9BsB,OAAAA,kBAAA;AA0NtB,SAAS,uBAAuB,QAA0B;AACxD,SAAO;AAAA,IACL,IAAI,OAAO;AAAA,IACX,UAAU,MAAM,QAAQ,OAAO,QAAQ,QAAQ,IAC3C,OAAO,OAAO,SAAS,CAAC,IACxB,OAAO,QAAQ,YAAY;AAAA,IAC/B,aAAa,OAAO,QAAQ,eAAe;AAAA,IAC3C,aAAa,OAAO,OAAO,QAAQ,gBAAgB,WAC/C,KAAK,MAAM,OAAO,OAAO,WAAW,IACpC,OAAO,QAAQ,eAAe,CAAC;AAAA,IACnC,YAAY,OAAO,QAAQ,cAAc;AAAA,IACzC,cAAc,OAAO,QAAQ,gBAAgB,OAAO,QAAQ;AAAA,IAC5D,WAAW,OAAO,QAAQ;AAAA,IAC1B,WAAW,OAAO,QAAQ;AAAA,EAC5B;AACF;AAfS;;;AD7VT,eAAsB,2BACpB,UACA,SACA,MACA,WACA,kBACe;AACf,MAAI,SAAS,OAAQ;AAErB,QAAM,WAAgC,CAAC;AAGvC,QAAM,cAAc,4BAA4B,SAAS,oBAAoB,CAAC,CAAC;AAC/E,MAAI,aAAa;AACf,aAAS,KAAK,WAAW;AAAA,EAC3B;AAGA,QAAM,cAAc,wBAAwB,OAAO;AACnD,MAAI,aAAa;AACf,aAAS,KAAK,WAAW;AAAA,EAC3B;AAGA,QAAM,iBAAiB,sBAAsB,SAAS,oBAAoB,CAAC,CAAC;AAC5E,MAAI,gBAAgB;AAClB,aAAS,KAAK,cAAc;AAAA,EAC9B;AAGA,QAAM,oBAAoB,yBAAyB,OAAO;AAC1D,MAAI,mBAAmB;AACrB,aAAS,KAAK,iBAAiB;AAAA,EACjC;AAGA,UAAQ,IAAI,kCAAkC,SAAS,QAAQ,yBAAyB;AAExF,aAAW,WAAW,UAAU;AAC9B,QAAI;AACF,cAAQ,IAAI,4CAA4C;AAAA,QACtD,MAAM,QAAQ;AAAA,QACd,YAAY,QAAQ;AAAA,QACpB,aAAa,QAAQ,YAAY;AAAA,MACnC,CAAC;AAGD,YAAM,mBAAmB,MAAMC,iBAAgB,UAAU,QAAQ,WAAW;AAC5E,YAAM,iBAAiB,iBAAiB;AAAA,QACtC,CAAC,MAAM,KAAK,UAAU,EAAE,WAAW,MAAM,KAAK,UAAU,QAAQ,WAAW;AAAA,MAC7E;AAEA,UAAI,gBAAgB;AAElB,gBAAQ,IAAI,8EAA8E,eAAe,UAAU;AACnH,cAAM,kBAAkB;AAAA,UACtB,GAAG;AAAA,UACH,YAAY,KAAK,IAAI,GAAG,eAAe,aAAa,GAAG;AAAA;AAAA,UACvD,cAAc;AAAA,QAChB,CAAC;AACD,gBAAQ,IAAI,mDAAmD;AAAA,MACjE,OAAO;AAEL,gBAAQ,IAAI,2CAA2C;AACvD,cAAM,kBAAkB;AAAA,UACtB;AAAA,UACA,aAAa,QAAQ;AAAA,UACrB,aAAa,QAAQ;AAAA,UACrB,YAAY,QAAQ;AAAA,UACpB,cAAc;AAAA,QAChB,CAAC;AACD,gBAAQ,IAAI,uDAAuD;AAAA,MACrE;AAAA,IACF,SAAS,OAAO;AAEd,cAAQ,MAAM,gDAAgD,KAAK;AACnE,cAAQ,MAAM,uCAAuC;AAAA,QACnD,aAAa,QAAQ;AAAA,QACrB;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC5D,OAAO,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,MAChD,CAAC;AAAA,IAEH;AAAA,EACF;AAEA,MAAI,SAAS,WAAW,GAAG;AACzB,YAAQ,IAAI,sDAAsD;AAAA,EACpE;AACF;AAzFsB;AA8FtB,SAAS,4BACP,SACA,kBAC0B;AAC1B,QAAM,eAAe,QAAQ,YAAY;AAGzC,QAAM,cAAc,aAAa,MAAM,uDAAuD;AAC9F,MAAI,CAAC,YAAa,QAAO;AAEzB,QAAM,cAAc,YAAY,CAAC,EAAE,KAAK;AAGxC,QAAM,WAAW,aAAa,MAAM,6EAA6E;AACjH,QAAM,YAAY,aAAa,MAAM,+BAA+B,KAClD,aAAa,MAAM,sBAAsB;AAG3D,QAAM,kBAAkB,iBAAiB;AAAA,IACvC,CAAC,MAAM,EAAE,SAAS,UAAU,EAAE,QAAQ,YAAY,EAAE,SAAS,YAAY,YAAY,CAAC;AAAA,EACxF,EAAE;AAEF,MAAI,mBAAmB,GAAG;AACxB,UAAM,YAAY,WAAW,aAAa,SAAS,CAAC,CAAC,IAAI;AACzD,UAAM,YAAY,YAAY,YAAY,SAAS,IAAI;AAEvD,WAAO;AAAA,MACL,aAAa;AAAA,MACb,aAAa;AAAA,QACX,aAAa,SAAS,WAAW,GAAG,cAAc,SAAY,OAAO,WAAW,SAAS,CAAC,KAAK,EAAE,GAAG,YAAY,OAAO,SAAS,KAAK,EAAE;AAAA,QACvI,WAAW,cAAc,SAAY,WAAW;AAAA,QAChD;AAAA,QACA;AAAA,QACA;AAAA,QACA,UAAU,EAAE,eAAe,gBAAgB;AAAA,MAC7C;AAAA,MACA,YAAY,KAAK,IAAI,KAAK,MAAM,kBAAkB,GAAG;AAAA,IACvD;AAAA,EACF;AAEA,SAAO;AACT;AAzCS;AA8CT,SAAS,wBAAwB,SAA2C;AAC1E,QAAM,eAAe,QAAQ,YAAY;AAGzC,QAAM,cAAc,6CAA6C,KAAK,YAAY;AAClF,QAAM,gBAAgB,sCAAsC,KAAK,YAAY;AAC7E,QAAM,cAAc,mCAAmC,KAAK,YAAY;AAExE,MAAI,eAAe,iBAAiB,aAAa;AAC/C,WAAO;AAAA,MACL,aAAa;AAAA,MACb,aAAa;AAAA,QACX,aAAa,WAAW,cAAc,YAAY,gBAAgB,cAAc,SAAS;AAAA,QACzF,WAAW,cAAc,UAAU,gBAAgB,UAAU;AAAA,MAC/D;AAAA,MACA,YAAY;AAAA,IACd;AAAA,EACF;AAEA,SAAO;AACT;AApBS;AAyBT,SAAS,sBACP,SACA,kBAC0B;AAC1B,QAAM,eAAe,QAAQ,YAAY;AAGzC,QAAM,iBAAiB,aAAa,MAAM,yEAAyE;AACnH,MAAI,CAAC,eAAgB,QAAO;AAE5B,QAAM,cAAc,eAAe,CAAC,EAAE,KAAK;AAG3C,QAAM,eAAe,iBAAiB;AAAA,IACpC,CAAC,MAAM,EAAE,QAAQ,YAAY,EAAE,SAAS,YAAY,YAAY,CAAC;AAAA,EACnE,EAAE;AAEF,MAAI,gBAAgB,GAAG;AACrB,WAAO;AAAA,MACL,aAAa;AAAA,MACb,aAAa;AAAA,QACX,aAAa,uBAAuB,WAAW;AAAA,QAC/C;AAAA,QACA,UAAU,EAAE,aAAa;AAAA,MAC3B;AAAA,MACA,YAAY,KAAK,IAAI,KAAK,MAAM,eAAe,GAAG;AAAA,IACpD;AAAA,EACF;AAEA,SAAO;AACT;AA9BS;AAmCT,SAAS,yBAAyB,SAA2C;AAC3E,QAAM,eAAe,QAAQ,YAAY;AAGzC,QAAM,qBAAqB;AAAA,IACzB;AAAA,IACA;AAAA,EACF;AAEA,aAAW,WAAW,oBAAoB;AACxC,QAAI,QAAQ,KAAK,YAAY,GAAG;AAC9B,aAAO;AAAA,QACL,aAAa;AAAA,QACb,aAAa;AAAA,UACX,aAAa,QAAQ,UAAU,GAAG,GAAG;AAAA;AAAA,UACrC,UAAU,EAAE,WAAW,KAAK;AAAA,QAC9B;AAAA,QACA,YAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAvBS;AA4BT,SAAS,aAAa,SAAyB;AAC7C,QAAM,OAA+B;AAAA,IACnC,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,WAAW;AAAA,IACX,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,UAAU;AAAA,EACZ;AACA,SAAO,KAAK,QAAQ,YAAY,CAAC,KAAK;AACxC;AAXS;AAgBT,SAAS,WAAW,KAAqB;AACvC,QAAM,OAAO,CAAC,UAAU,UAAU,WAAW,aAAa,YAAY,UAAU,UAAU;AAC1F,SAAO,KAAK,GAAG,KAAK;AACtB;AAHS;AAQT,SAAS,YAAY,OAAiC;AACpD,MAAI,MAAM,CAAC,GAAG;AAEZ,QAAI,OAAO,SAAS,MAAM,CAAC,CAAC;AAC5B,UAAM,SAAS,MAAM,CAAC,IAAI,SAAS,MAAM,CAAC,CAAC,IAAI;AAC/C,UAAM,OAAO,MAAM,CAAC,GAAG,YAAY,KAAK,MAAM,CAAC,GAAG,YAAY;AAE9D,QAAI,SAAS,QAAQ,SAAS,GAAI,SAAQ;AAC1C,QAAI,SAAS,QAAQ,SAAS,GAAI,QAAO;AAEzC,WAAO,GAAG,KAAK,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC,IAAI,OAAO,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,EAClF,OAAO;AAEL,UAAM,OAAO,SAAS,MAAM,CAAC,CAAC;AAC9B,UAAM,SAAS,MAAM,CAAC,IAAI,SAAS,MAAM,CAAC,CAAC,IAAI;AAC/C,WAAO,GAAG,KAAK,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC,IAAI,OAAO,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,EAClF;AACF;AAjBS;;;ADrQT;AACA;AAMO,IAAM,sBAAsB,KAAK;AAAA,EACtC,IAAI;AAAA,EACJ,KAAK,8BAAO,YAUN;AACJ,QAAI;AACF,cAAQ,IAAI,+CAA+C;AAAA,QACzD,UAAU,QAAQ;AAAA,QAClB,eAAe,QAAQ,QAAQ;AAAA,MACjC,CAAC;AAED,YAAM;AAAA,QACJ,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,QAAQ,oBAAoB,CAAC;AAAA,MAC/B;AAEA,cAAQ,IAAI,qDAAqD;AACjE,aAAO,EAAE,SAAS,KAAK;AAAA,IACzB,SAAS,OAAO;AACd,cAAQ,MAAM,wCAAwC,KAAK;AAC3D,YAAM;AAAA,IACR;AAAA,EACF,GA/BK;AAgCP,CAAC;AAKM,IAAM,2BAA2B,KAAK;AAAA,EAC3C,IAAI;AAAA,EACJ,KAAK,8BAAO,YAON;AACJ,QAAI;AACF,cAAQ,IAAI,gDAAgD;AAAA,QAC1D,UAAU,QAAQ;AAAA,QAClB,cAAc,QAAQ,SAAS;AAAA,MACjC,CAAC;AAED,YAAM,UAAU,CAAC;AACjB,iBAAW,OAAO,QAAQ,UAAU;AAClC,YAAI;AACF,gBAAM;AAAA,YACJ,QAAQ;AAAA,YACR,IAAI;AAAA,YACJ,IAAI;AAAA,YACJ,IAAI;AAAA,YACJ,QAAQ,SAAS,OAAO,OAAK,EAAE,YAAY,IAAI,SAAS;AAAA,UAC1D;AACA,kBAAQ,KAAK,EAAE,SAAS,MAAM,SAAS,IAAI,QAAQ,UAAU,GAAG,EAAE,EAAE,CAAC;AAAA,QACvE,SAAS,OAAO;AACd,kBAAQ,MAAM,qDAAqD,KAAK;AACxE,kBAAQ,KAAK,EAAE,SAAS,OAAO,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,EAAE,CAAC;AAAA,QAChG;AAAA,MACF;AAEA,aAAO,EAAE,SAAS,OAAO,QAAQ,SAAS,QAAQ,YAAY,QAAQ,OAAO,OAAK,EAAE,OAAO,EAAE,OAAO;AAAA,IACtG,SAAS,OAAO;AACd,cAAQ,MAAM,8CAA8C,KAAK;AACjE,YAAM;AAAA,IACR;AAAA,EACF,GApCK;AAqCP,CAAC;AAKM,IAAM,0BAA0B,KAAK;AAAA,EAC1C,IAAI;AAAA,EACJ,KAAK,8BAAO,YAEN;AACJ,QAAI;AACF,cAAQ,IAAI,4CAA4C;AAAA,QACtD,UAAU,QAAQ;AAAA,MACpB,CAAC;AAED,YAAM,WAAW,MAAM,gBAAgB,QAAQ,QAAQ;AAGvD,YAAM,eAAe,oBAAI,IAA0B;AAEnD,iBAAW,UAAU,UAAU;AAE7B,cAAM,UAAU,OAAO,IAAI,MAAM,GAAG,EAAE,CAAC,KAAK,OAAO;AAEnD,YAAI,CAAC,aAAa,IAAI,OAAO,GAAG;AAC9B,uBAAa,IAAI,SAAS,CAAC,CAAC;AAAA,QAC9B;AACA,qBAAa,IAAI,OAAO,EAAG,KAAK,MAAM;AAAA,MACxC;AAGA,UAAI,eAAe;AACnB,iBAAW,CAAC,SAAS,KAAK,KAAK,aAAa,QAAQ,GAAG;AACrD,YAAI,MAAM,SAAS,GAAG;AAEpB,gBAAM,UAAU,MAAM,KAAK,CAAC,GAAG,MAAM;AACnC,kBAAM,kBAAkB,EAAE,MAAM,GAAG,QAAQ,GAAG,KAAK,EAAE;AACrD,kBAAM,OAAO,gBAAgB,EAAE,cAAc,QAAQ;AACrD,kBAAM,OAAO,gBAAgB,EAAE,cAAc,QAAQ;AACrD,gBAAI,SAAS,KAAM,QAAO,OAAO;AAEjC,kBAAM,QAAQ,EAAE,YAAY,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAAI;AAC9D,kBAAM,QAAQ,EAAE,YAAY,IAAI,KAAK,EAAE,SAAS,EAAE,QAAQ,IAAI;AAC9D,mBAAO,QAAQ;AAAA,UACjB,CAAC,EAAE,CAAC;AAGJ,gBAAM,WAAW,MACd,OAAO,OAAK,EAAE,OAAO,QAAQ,MAAM,EAAE,OAAO,EAC5C,IAAI,OAAK,EAAE,OAAO,EAClB,OAAO,OAAO;AAEjB,cAAI,SAAS,SAAS,GAAG;AACvB,oBAAQ,UAAU,CAAC,QAAQ,SAAS,GAAG,QAAQ,EAAE,OAAO,OAAO,EAAE,KAAK,IAAI;AAAA,UAC5E;AAGA,gBAAM,iBAAiB,OAAO;AAG9B,0BAAgB,MAAM,SAAS;AAAA,QACjC;AAAA,MACF;AAGA,YAAM,MAAM,oBAAI,KAAK;AACrB,YAAM,UAAU,SAAS,OAAO,OAAK,EAAE,aAAa,IAAI,KAAK,EAAE,SAAS,IAAI,GAAG;AAG/E,cAAQ,IAAI,mBAAmB,QAAQ,MAAM,iDAAiD;AAE9F,cAAQ,IAAI,6CAA6C;AAAA,QACvD,eAAe,SAAS;AAAA,QACxB;AAAA,QACA,SAAS,QAAQ;AAAA,MACnB,CAAC;AAED,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe,SAAS;AAAA,QACxB;AAAA,QACA,SAAS,QAAQ;AAAA,MACnB;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,0CAA0C,KAAK;AAC7D,YAAM;AAAA,IACR;AAAA,EACF,GAhFK;AAiFP,CAAC;AAKM,IAAM,8BAA8B,KAAK;AAAA,EAC9C,IAAI;AAAA,EACJ,KAAK,8BAAO,YAEN;AACJ,QAAI;AACF,cAAQ,IAAI,iDAAiD;AAAA,QAC3D,UAAU,QAAQ;AAAA,MACpB,CAAC;AAED,YAAM,WAAW,MAAM,gBAAgB,QAAQ,QAAQ;AAGvD,YAAM,WAAW,MAAM,kDAA0B,oBAAoB,QAAQ,QAAQ;AACrF,YAAM,iBAAiB,MAAM,gBAAgB;AAAA,QAC3C;AAAA,QACA,OAAO;AAAA,MACT,CAAC;AAED,UAAI,UAAU;AACd,iBAAW,WAAW,UAAU;AAC9B,YAAI,UAAU;AAGd,mBAAW,OAAO,eAAe,UAAU;AACzC,gBAAM,WAAW,IAAI,QAAQ,YAAY;AACzC,gBAAM,cAAc,QAAQ,YAAY,aAAa,YAAY,KAAK;AAGtE,cAAI,eAAe,SAAS,SAAS,YAAY,MAAM,GAAG,EAAE,CAAC,CAAC,GAAG;AAC/D;AAAA,UACF;AAAA,QACF;AAGA,YAAI,UAAU,GAAG;AACf,gBAAM,gBAAgB,KAAK,IAAI,IAAI,QAAQ,cAAc,OAAQ,UAAU,GAAI;AAC/E,cAAI,kBAAkB,QAAQ,YAAY;AACxC,kBAAM,kDAA0B,kBAAkB;AAAA,cAChD,GAAG;AAAA,cACH,YAAY;AAAA,cACZ,eAAc,oBAAI,KAAK,GAAE,YAAY;AAAA,YACvC,CAAC;AACD;AAAA,UACF;AAAA,QACF,OAAO;AAEL,gBAAM,gBAAgB,KAAK,IAAI,MAAM,QAAQ,cAAc,OAAO,IAAI;AACtE,cAAI,kBAAkB,QAAQ,YAAY;AACxC,kBAAM,kDAA0B,kBAAkB;AAAA,cAChD,GAAG;AAAA,cACH,YAAY;AAAA,YACd,CAAC;AACD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,cAAQ,IAAI,kDAAkD;AAAA,QAC5D,eAAe,SAAS;AAAA,QACxB;AAAA,MACF,CAAC;AAED,aAAO;AAAA,QACL,SAAS;AAAA,QACT,eAAe,SAAS;AAAA,QACxB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,+CAA+C,KAAK;AAClE,YAAM;AAAA,IACR;AAAA,EACF,GAtEK;AAuEP,CAAC;",
  "names": ["response", "result", "getUserPatterns", "getUserPatterns"]
}
